---
layout: post
title: "메모리 관리 전략(Memory Managing Strategy) 및 가상 메모리 (Virtual Memory)"
image: '/assets/img/'
description: '메모리 관리 전략(Memory Managing Strategy) 및 가상 메모리 (Virtual Memory)'
tags:
- OS
categories:
- OS
---

## 메모리 관리 전략(Memory Managing Strategy) 및 가상 메모리 (Virtual Memory)

이번 포스팅에는 메모리 관리 전략과 가상 메모리에 대해서 다뤄보도록 하겠습니다.

가상 메모리는 한정된 크기의 메모리내에서 최대한 많은 프로세스를 할당하여 효율적으로 사용하기 위해 만든 기술로, 간단히 말하면 보조 기억장치를 주기억장치 처럼
사용할 수 있게 하는 기술입니다. 이를 통해 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있습니다.

예전에는 실행되는 코드의 전부를 물리 메모리에 할당하여야 했고, 메모리 용량보다 큰 프로그램은 실행을 할 수가 없었습니다.
또 여러 프로그램을 메모리에 동시에 올리기에는 용량의 한계와 페이지 교체등의 이슈가 발생하였습니다. 하지만 가상 메모리가 개발 되면서
물리 메모리 크기에 제약을 받지 않게되었고 더 많은 프로그램을 동시에 실행할 수 있게 되었고, swap에 필요한 I/O가 줄어들기 때문에
프로그램들이 빠르게 실행 할 수 있습니다.

가상 메모리의 장점
- 더 많은 프로그램을 실행할 수 있다.
- 실제 물리 메모리의 크기에 제한을 받지 않는다.
- 프로그램의 swap에 필요한 입출력 감소 (=프로세스의 일부분만 swap하도록 처리)

---

### 메모리 관리 전략

메모리는 CPU가 직접 접근하는 유일한 저장장치로 메모리 시스템(하드웨어)은 주소(메모리 위치)를 관리하며 할당과 접근을 제어합니다.

목적
- 제한된 물리 메모리의 효율적인 사용 (할당)
- 효율적인 메모리 참조 (논리-물리 주소 할당)

이를 위한 메모리 전략은 크게 3가지가 있습니다.

#### 스와핑 (Swapping)

![](https://miro.medium.com/max/1000/1*m8Eghg9oNMLMl8_IQVN3BQ.png)

CPU에서 실행 중이지 않은 프로세스의 메모리 이미지를 저장장치에 이동 (메모리 사용의 효율성 증가)

- Swap in : Ready Queue의 다음 프로세스가 메모리에 없다면
- Swap out : 메모리 공간이 부족하면 다른 프로세스를 Swap out 후 Swap in
- 단점 : Context Switching Overhead

---

#### 연속 메모리 할당 (Contiguous Memory Allocation)

- 각 프로세스가 필요로 하는 메모리 요구량을 분석해서 필요한 메모리를 연속으로 메모리에 할당하는 방식 (연속된 물리 메모리이기 때문에 시작 주소만 알면 됨)
- 동적 메모리 할당 : 어떤 프로세스가 실행했을때 이 프로세스가 들어갈 적당한 곳을 찾아 할당하는 것
    - 최초 적합 (First-fit) : 요청한 크기를 만족하는 첫 번재 가용 공간을 할당, 속도가 빠름
    - 최적 적합 (Best-fit) : 요청한 크기를 만족하는 가장 작은 공간을 할당, 남는 가용 곤간을 최소화함
    - 최악 적합 (Worst-fit) : 가장 큰 가용 공간을 할당, 가용 공간이 커서 활용 가능성이 높음, 검색속도가 느리고, 메모리 이용 효율이 좋지 않음

---

####  페이징 (Paging)

![](https://miro.medium.com/max/1000/1*TuZX6dsVI8RvR1S4hcclJQ.png)

- 프로세스가 사용하는 주소 공간을 여러 개로 분할하여 비연속적인 물리 메모리 공간에 할당, 가상 메모리를 모두 같은 크기의 블록으로 편
- 단위
    - 프레임 : 실제 메모리 공간 (4KB)
    - 페이지 : 프로세스의 메모리 공간 (4KB)
    - 프레임 사이즈 = 페이지 사이즈
    - 논리적 의미와 관계없이 크기가 모두 동일함
- 페이지 테이블
    - 페이지 테이블 내에 프레임과 페이지가 서로 매핑이 되어 있어서 페이지 테이블을 참조하여 실제 메모리에 접근하게 됩니다.
    - 문제 : 매번 메모리의 페이지 테이블을 먼저 읽어야 하므로 메모리 접근 시간이 두 배가 된다 -> 페이지 테이블의 캐싱을 사용
- 페이징과 Context Switching : 페이지 테이블을 재설정하기 위한 `Context Switching`이 발생
- 공유 페이지 : 비교적 간단하게 메모리 공유

---

#### 세그멘테이션 (Segmentation)

![](https://miro.medium.com/max/1000/1*xLMVNt4u00UvP3XnNOlMaw.png)

- 프로세스가 필요로 하는 메모리 공간을 분할하여 비연속적인 물리 메모리 공간에 할당
- 단위 : 세그먼트 (서로 다른 크기를 가짐)
- 페이징과의 차이
    - 논리적 의미에 부합하도록 세그먼트들의 크기가 서로 다름 
    - 크기가 다 다르기 때문에 메모리를 페이징 기법에서처럼 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당
- 논리 주소 공간을 세그먼트 집합으로 정의 (세그먼트마다 별도의 독립된 주소 공간 제공)
- 세그먼트 테이블
    - 사용자가 정의한 주소를 실제 주소로 맵핑하는 정보를 저장하고 있음
    - 개별 세그먼트는 항목별로 Base(세그먼트 시작 주소) + Limit(세그먼트 길이)의 정보를 같습니다.

#### 페이징 (Paging) vs 세그멘테이션 (Segmentation)

| | 페이징 | 세그멘테이션
| :---: | :--- | :---
| 단위 | 페이지(가상 공간) / 프레임(물리 공간) | 세그먼트
| 차이점 | 페이지와 프레임이 모두 같은 크기 | 논리적 의미에 따라 서로 다른 크기의 세그먼트를 가

---

### 요구 페이징 (Demand Paging)

- 스왑된 페이지를 필요할 때 메모리에 적재
- 기본적인 페이징 기법에 따라 주소 변환
- 논리 주소 공간의 각 페이지가 실제로 필요해질 때 적재
    - 사용되지 않는 페이지는 메모리에 적재하지 않음
    - 물리 메모리의 필요 용량을 감소
    - 스왑에 필요한 시간 감소
- 가상 메모리를 구현하는 중요한 기반 기술
    - 세그먼테이션 시스템에서도 페이징과 결합하여 구현
- 스와핑 기법과 유사
    - 프로세스 전체를 저장/복구 vs 필요한 페이지만 저장/복구
    - 가상메모리에서는 swapper보다는 pager란 용어가 더 적합
    
    
---

### 페이지 교체 (Page Replacement)

![](https://miro.medium.com/max/700/1*pZMlETpX_C0TWgUSLWhkaQ.png)

메모리 공간이 부족하면 특정 페이지를 스왑하여 교체

- 페이지 교체 알고리즘 (page replacement)
    - `FIFO (First-In-First-Out)`
        - 메모리에 적재된 시간이 가장 오래된 페이지를 교체 (프레임 개수가 많아지면 페이지 부재율이 높아지는 현상, Belady의 모순)
    - `Optimal Page Replace`
        - 앞으로 가장 오래 사용되지 않을 페이지를 교체, 들어온 데이터를 쭉 읽어서 앞으로 사용하지 않을걸 교체
        - 다른 모든 알고리즘보다 페이지 부재율이 낮으면서 Belady의 모순이 발생하지 않는 페이지 교체 알고리즘
        - 실제 구현이 불가능하다 : 미래의 페이지 참조를 미리 알아야 함
        - 제안된 알고리즘의 성능을 비교하기 위한 목적으로 사용
    - `LRU (Least-Recent-Used)`
        - 가장 오랫동안 사용되지 않은 페이지를 교체
        - 최적 페이지 교체 알고리즘에 근사하는 방법, 과거 참조를 기반으로 미래 참조 형태의 근사치를 결정
        - 거의 최적 알고리즘에 가까움
        - 링크드 리스트로 관리 (스택으로 유지)
        - 고려사항
            - 페이지들을 최근에 사용한 시간 순서대로 나열할 수 있어야 함
            - 하드웨어의 지원이 필요 : 모든 메모리 참조에 대해 참조 시간 정보를 갱신
    - `LFU (Least-Frequently-Used)`
        - 참조 횟수가 가장 적은 페이지를 교체
        - 참조 횟수가 적은건 앞으로도 안쓸것이다.
        - 참조 빈도와 참조 시간은 정확히 일치하지 않습니다.
    - `MFU (Most-Frequently-Used)`
        - 참조 횟수가 가장 많은 페이지를 교체
        - 최근에 참조가 된 페이지는 앞으로 덜 쓸것이다.
        - 참조 횟수가 적은 페이지는 최근에 적재되었고 앞으로 참조될 가능성이 높을 것이라는 직관에 의존
- 프레임 할당 알고리즘 (frame allocation)
- 요구 페이징은 시스템 성능에 많은 영향을 준다.
- 페이지 교체 알고리즘의 목표 : `Page Fault Rate`의 최소화
- Page Fault : 접근하려는 페이지가 메모리에 없는 상태
- 페이지 버퍼링
    - Demand Paging의 디스크 I/O를 개선하는 방법
        - 가용 프레임 집합 유지
        - 변경된 페이지 목록 유지
        - 가용 프레임의 이전 페이지 번호 저장

